*****************************
PROBLEM SET
*****************************
Caesar Cipher

Implement a program that encrypts messages using Caesar’s cipher, per the below.

$ ./caesar 13
plaintext:  HELLO
ciphertext: URYYB

SOLUTION:
#include <stdio.h>
#include <string.h>
#include <cs50.h>
#include <ctype.h>

int main(int argc, string argv[])  // accepts command line arguments which will always be a string
{
    if (argc != 2)// more or less than one input will make argc not equal 2
    {
        printf("Please enter a single positive integer as a key\n");
        return 1;
    }

    int key = atoi(argv[1]); // convert the string at argv[1] to int

    if (key < 0) // the key needs to be a positive int
    {
        printf("Please enter a single positive integer as a key\n");
        return 1;
    }

    // we are given the cipher equation Ci = (Pi + k ) % 26. ASCII A is 65, ASCII a is 97. 'A' is the 0-th uppercase letter.
    // I need to subtract 65 from the given uppercase letter to access the index in the alphabet. Then I need to add the key to
    // shift the letter. From here I need the modulus of 26 in the event that the key is larger than 26. Finally
    // I need to add 65 back to the value to convert it back to an uppercase letter. Repeat for lowercase with 'a'.
    string message = get_string("Plaintext: ");

    for (int  i = 0, n = strlen(message); i < n; i++)
    {
        if (isalpha(message[i]))
        {
            if (isupper(message[i]))
            {
                message[i] = ((message[i] - 65 + key) % 26) + 65;
            }
            if (islower(message[i]))
            {
                message[i] = ((message[i] - 97 + key) % 26) + 97;
            }
        }
    }
    printf("ciphertext: %s\n", message);
    return 0;
}

//////////////////////////////////////
Vigenere cipher

Implement a program that encrypts messages using Vigenère’s cipher, per the below.

$ ./vigenere ABC
plaintext:  HELLO
ciphertext: HFNLP

SOLUTION

#include <stdio.h>
#include <string.h>
#include <cs50.h>
#include <ctype.h>

int main(int argc, string argv[])  // accepts command line arguments which will always be a string
{
    printf("%s\n", argv[1]);
    if (argc != 2)// more or less than one input will make argc not equal 2
    {
        printf("Please enter a single word as a key\n");
        return 1;
    }


    //need to ensure key is alpha only
    for (int i = 0; i < strlen(argv[1]); i++)
    {
        if (!isalpha(argv[1][i]))
        {
            printf("Please enter a single word as a key\n");
            return 1;
        }
    }

    string key = argv[1]; //key needs to be all lower case
    int keyLen = strlen(key);
    for (int kl = 0; kl < keyLen; kl++)
    {
        key[kl] = tolower(key[kl]);
    }
    // we are given the cipher equation Ci = (Pi + Kj ) % 26. ASCII A is 65, ASCII a is 97. 'A' is the 0-th uppercase letter.
    // I need to subtract 65 from the given uppercase letter to access the index in the alphabet. Then I need to add the key to
    // shift the letter. From here I need the modulus of 26 in the event that the key is larger than 26. Finally
    // I need to add 65 back to the value to convert it back to an uppercase letter. Repeat for lowercase with 'a'.
    // ONLY do this if the character in plaintext is a letter.

    string message = get_string("Plaintext: ");

    for (int  i = 0, n = strlen(message), j = 0; i < n; i++)
    {
        if (isalpha(message[i]))
        {
            if (isupper(message[i]))
            {
                message[i] = ((message[i] - 'A') + (key[(j++) % keyLen] - 'a')) % 26 + 'A';
            }
            else if (islower(message[i]))
            {
                message[i] = ((message[i] - 'a') + (key[(j++) % keyLen] - 'a')) % 26 + 'a';
            }
        }
    }

    printf("ciphertext: %s\n", message);
    return 0;

}

*****************************
CLASS NOTES
*****************************
DEBUGGERS: click the number in the gutter to add a breakpoint then run
debug50 ./program

DATA TYPES:
%s = string
%i = integer
%f = float
%lld = long_long_decimal

man get_string => manual for get_string

get the i-th character of a string: printf("%c", s[i]);
string length: strlen(stringName)

class samples:
Capitalize:
int main(void)
{
  string s = get_string("before: ");
  printf("after: ");
  for (int i =0, n = strlen(s); i < n; i++)
  {
    if(s[i] >= 'a' && s[i] <= 'z')
    {
      printf("%c", s[i] - ('a' - 'A'));
    }
    else
    {
      printf("%c", s[i]);
    }
  }
  printf("\n");
}

At end of string?
int main(void)
{
  string s - get_string("Name: ");
  int n = 0;
  while(s[n] != '\0')  // \0 is the end of string escape/null character
  {
    n++
  }
  printf("%i\n");
}
represent multiple variables in a single data type: array
int main(void):  main programs will return an integer value (0) but no arguments (void)
int main(int argc, string argv[]):  argv (argument vector) 0: program name, 1: 1st argument passed in
argc is the COUNT of the ARGUMENTS while argv is an array of the ARGUMENTS

try to access a value that doesn't exist: segmentation fault (JS will just give undefined)

int main(int argc, string argv[])
{
  if (argc == 2)
  {
    printf("hello, %s\n", argv[1]);
  }
  else
  {
    printf("hello, world\n");
  }
}

Cryptography
Needs and algorithm so the message can be converted back to something meaningful
requires a key
refers to cracking hashed passwords
CHRISTMAS STORY!! Ralphie's decoder ring.
